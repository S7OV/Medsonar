# -*- coding: utf-8 -*-
"""1. Модуль транскрибации аудиозаписей

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UT0S2sTJ7bA4k8ytH7CcupIWH0fk4RHO

![image.png](data:image/png;base64,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)

# Модуль загрузки и транскрибации файлов (первый этап)

Данный модуль загружает и обрабатывает {MAX_RECORDS} аудио файлов от каждого менеджера из общей папки.

На входе нужно указать настройки на листе Конфигурация в рабочей таблице.

На выходе транскрибации будут сохранены в рабочую таблицу в лист Транскрибации RAW.

### ======== Служебные функции ========
"""

# @title Разное

import re

# Функция для загрузки MP3 файла с Google Drive
def load_mp3_from_google_drive(file_id: str, file_name: str) -> bytes:
    try:
        # Определение URL для загрузки файла
        download_url = f'https://drive.google.com/uc?id={file_id}&export=download'

        # Загрузка файла
        response = requests.get(download_url)
        response.raise_for_status()  # Проверка на успешность ответа

        # Сохранение MP3 файла во временный файл
        with open(file_name, "wb") as f:
            f.write(response.content)

        return response.content

    except requests.RequestException as e:
        print(f"Ошибка при загрузке файла: {e}")
        return None

    except IOError as e:
        print(f"Ошибка при сохранении файла: {e}")
        return None

# Функция для форматирования текста
def format_transcript(text):
    # Добавляем пробелы после знаков препинания, если их нет
    text = re.sub(r'([.!?])([^\s])', r'\1 \2', text)

    # Разделяем текст по знакам препинания, сохраняя сами знаки
    sentences = re.split(r'([.!?])', text)

    formatted_text = ''

    for i in range(0, len(sentences) - 1, 2):
        sentence = sentences[i].strip()
        punctuation = sentences[i + 1].strip()
        formatted_text += sentence + punctuation + '\n'

    # Добавляем последнюю часть текста, если она существует
    if len(sentences) % 2 != 0:
        formatted_text += sentences[-1].strip()

    return formatted_text

# Функция для расчета стоимости транскрибации
def calculate_cost(duration_seconds):
    # Стоимость транскрибации Whisper на момент написания (уточните стоимость у OpenAI)
    cost_per_minute = 0.006  # Долларов за минуту
    cost = (duration_seconds / 60) * cost_per_minute
    return cost

# Функция для извлечения дополнительных данных из имени файла
def get_audio_info(filename):
    # Шаблон регулярного выражения для извлечения информации
    pattern = r'.*(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})\.\d+_from_(\d+)_to_(\d+)_session_(\d+)_\w+'

    # Применяем регулярное выражение к имени файла
    match = re.match(pattern, filename)

    if match:
        # Извлекаем данные из групп регулярного выражения
        date_time = match.group(1)  # Дата-время
        from_number = match.group(2)  # От кого звонок
        to_number = match.group(3)  # Кому звонок
        session_id = match.group(4)  # Номер сессии

        audio_info = {
            "filename": filename,
            "date_time": date_time,
            "from_number": from_number,
            "to_number": to_number,
            "session_id": session_id,
        }

    else:
        # В случае ошибки возвращаем словарь с именем файла и прочерками
        audio_info = {
            "filename": filename,
            "date_time": "---",
            "from_number": "---",
            "to_number": "---",
            "session_id": "---",
        }

    return audio_info


# Проверка функции и вывод результата
filename = "2024-06-24_12-15-45.096841_from_79615079433_to_049360_session_4109971104_talk.mp3"
audio_info = get_audio_info(filename)
print(audio_info)

# @title Получаем список файлов датасета
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
from googleapiclient.errors import HttpError


def get_audio_list(folder_id_url, status_widget):
    # Начинаем с пустого списка статусов
    status_log = []

    # Функция для обновления статуса и отображения в `status_widget`
    def update_status(new_status, is_temporary=False):
        nonlocal status_log
        if is_temporary:
            # Удаляем старый временный статус и добавляем новый
            status_log = [status for status in status_log if not status.startswith('🕑 Обработка файлов')]
            status_log.append(new_status)
        else:
            # Добавляем новый статус и удаляем все временные статусы с часами
            status_log = [status for status in status_log if '🕑' not in status]
            status_log.append(new_status)

        # Обновляем `status_widget` значением, состоящим из всех статусов, соединенных через <br>
        status_widget.value = "<br>".join(status_log)


    progress.value = 10  # Обновляем прогресс
    # Статус: Аутентификация
    update_status('🕑 Аутентификация Google...', is_temporary=True)
    sleep(0.5)  # Симуляция длительной операции
    # Проверяем значение stopLoop из JavaScript
    if check_stop_loop():
        return

    # Аутентификация
    auth.authenticate_user()
    gauth = GoogleAuth()
    gauth.credentials = GoogleCredentials.get_application_default()
    drive = GoogleDrive(gauth)

    # Статус: Аутентификация завершена
    update_status('✅ Аутентификация Google завершена.')
    sleep(0.5)
    # Проверяем значение stopLoop из JavaScript
    if check_stop_loop():
        return

    # Статус: Извлечение ID из ссылки
    update_status('🕑 Извлечение ID папки из ссылки...', is_temporary=True)
    sleep(0.5)
    # Проверяем значение stopLoop из JavaScript
    if check_stop_loop():
        return
    progress.value = 15  # Обновляем прогресс

    pattern = r'folders/([a-zA-Z0-9_-]+)'
    match = re.search(pattern, folder_id_url)
    if not match:
        raise ValueError("Неверный формат ссылки. Убедитесь, что ссылка содержит 'folders/<folder_id>'.")

    folder_id = match.group(1)
    update_status('✅ ID папки успешно извлечен.')

    # Статус: Проверка существования папки
    update_status('🕑 Проверка существования папки...', is_temporary=True)
    try:
        for i in range(20, 30, 2):
            progress.value = i
            sleep(0.1)  # Задержка для более плавного обновления прогресса
            # Проверяем значение stopLoop из JavaScript
            if check_stop_loop():
                return
        drive.ListFile({'q': f"'{folder_id}' in parents and trashed=false"}).GetList()
        update_status('✅ Папка найдена.')
    except HttpError as e:
        if e.resp.status == 404:
            update_status('❌ Папка не найдена.')
            raise ValueError(f"Папка {folder_id_url} не найдена.")
        else:
            update_status('❌ Ошибка при проверке папки.')
            raise



    # Статус: Получение списка файлов
    update_status('🕑 Получение списка файлов из папки...', is_temporary=True)
    for i in range(30, 50, 4):
        progress.value = i
        sleep(0.01)  # Задержка для более плавного обновления прогресса


    audio_list = []
    file_list = drive.ListFile({'q': f"'{folder_id}' in parents and trashed=false"}).GetList()
    total_files = len(file_list)
    update_status(f'✅ Список файлов получен. Всего файлов: {total_files}.')


    # Статус: Обработка файлов
    update_status(f'🕑 Обработка файлов... (0 из {total_files})', is_temporary=True)
    for idx, file in enumerate(file_list):
        file_size = int(file.get('fileSize', 0))  # Получение размера файла и преобразование в int
        FILTER = int(config['FILTER_AUDIO_SIZE'])
        if FILTER == 0 or file_size > FILTER:
            audio_info = get_audio_info(file['title'])
            audio_info['id'] = file['id']
            audio_list.append(audio_info)
    # Проверяем значение stopLoop из JavaScript
    if check_stop_loop():
        return

        # Обновление прогресса от 60 до 80 в зависимости от обработки файлов
        sleep(0.01)  # Задержка для более плавного обновления прогресса
        progress.value = 55 + int(20 * (idx + 1) / total_files)  # Прогресс от 60 до 80

        # Обновление статуса с указанием количества обработанных файлов
        if (idx + 1) % 100 == 0 or (idx + 1) == total_files:
            update_status(f'🕑 Обработка файлов... ({idx + 1} из {total_files})', is_temporary=True)
    # Проверяем значение stopLoop из JavaScript
    if check_stop_loop():
        return

    progress.value = 75  # Обновляем прогресс
    # Явное удаление временного статуса перед добавлением финального сообщения
    status_log = [status for status in status_log if not status.startswith('🕑 Обработка файлов')]
    update_status(f'✅ Обработка завершена. Всего обработано файлов: {len(audio_list)}.')

    return audio_list

# @title Получаем краткий список файлов по операторам
from collections import defaultdict

def get_records_by_list(audio_list, max_records=5):

    unique_to_numbers = defaultdict(list)
    original_counts = defaultdict(int)

    # Заполняем словари
    for record in audio_list:
        unique_to_numbers[record['to_number']].append(record)
        original_counts[record['to_number']] += 1

    # Фильтруем номера, у которых меньше max_records записей
    max_records = int(max_records)
    filtered_to_numbers = {to_number: records for to_number, records in unique_to_numbers.items() if len(records) >= max_records}

    # Составляем результат, включая не более max_records записей для каждого номера
    result = [rec for to_number in filtered_to_numbers for rec in filtered_to_numbers[to_number][:max_records]]

    return result, original_counts

# @title Работа с WHISPER API

def run_transcript(record, file_name):
    if not 'text' in record:
        # Создание клиента OpenAI
        client = openai.OpenAI()

        # Указываем слова в параметре prompt МОЖНО ДОПОЛНЯТЬ ДЛЯ ЛУЧШЕЙ ТРАНСКРИБАЦИИ:
        prompt = "клиника Медсонар, оператор, Петра Метальникова, Бочарникова"

        # Получение длительности аудиофайла
        audio_segment = AudioSegment.from_file(file_name, format="mp3")
        audio_duration = audio_segment.duration_seconds

        if audio_duration > 1:
            # Выполнение транскрибации с параметром prompt и замер времени выполнения
            start_time = time.time()
            transcript = client.audio.transcriptions.create(
                model="whisper-1",
                file=open(file_name, "rb"),
                prompt=prompt
            )
            end_time = time.time()
            elapsed_time = end_time - start_time

            # Обработка и форматирование текста
            text = transcript.text
            formatted_text = format_transcript(text)
            cost = calculate_cost(audio_duration)
        else:
            formatted_text = 'error'
            cost = 0
            elapsed_time = 0

        return {
            "text": formatted_text,
            "duration": round(audio_duration, 2),
            "elapsed_time": round(elapsed_time, 2),
            "cost": round(cost, 4)
        }

# @title Функции взаимодействия с кнопкой "Отмена"
# Функция для проверки значения stopLoop из JavaScript
from google.colab import output
def check_stop_loop():
    return output.eval_js('stopLoop')

# Функция для сброса флага остановки stopLoop из JavaScript
def reset_stop_loop():
    return output.eval_js('resetStopLoop()')

# Функция для установки флага остановки stopLoop из JavaScript
def set_stop_loop():
    return output.eval_js('setStopLoop()')

# @title Вывод информации по выбранным записям

from datetime import datetime
def on_upload_button_click(b):
    upload_button.disabled = True
    transcription_button.disabled = True
    cancel_button.disabled = False

    progress.value = 0

    with output_area:
        clear_output()

        # Перезагрузка основной Конфигурации из Google Spreadsheets
        # Создаем виджет для отображения текста
        config_widget = widgets.HTML('<h2>🕑 Загрузка основной Конфигурации из рабочей таблицы...</h2>')
        config_widget.add_class('config-widget')
        display(config_widget)

        global config  # Указываем, что будем использовать глобальную переменную
        config = re_config(gs_client, colab_id, spreadsheet_url)

        sleep(1)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return
        # Обновляем текст в виджете
        progress.value = 5  # Обновляем прогресс
        config_widget.value = '<h2>✅ Конфигурация успешно загружена.</h2>'

        # Создаем виджет для отображения текста
        audio_widget = widgets.HTML('<h2>🕑 Получаю список аудиозаписей...</h2>')
        audio_widget.add_class('audio-widget')
        status_widget = widgets.HTML('')
        status_widget.add_class('status-widget')

        display(audio_widget)
        sleep(1)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return
        display(status_widget)

        sleep(.5)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        global records_list  # Указываем, что будем использовать глобальную переменную

        # Загружаем список файлов из расшаренной папки на Google Drive
        audio_list = get_audio_list(config['GOOGLE_DRIVE_AUDIO_URL'], status_widget)

        # Обновляем текст в виджете
        progress.value = 80  # Обновляем прогресс
        audio_widget.value = '<h2>✅ Аудиозаписи успешно загружены.</h2>'

        sleep(.3)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return
        #clear_output()

        # Назначаем класс для первого виджета
        status_widget.add_class('hidden')
        sleep(.1)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        # Назначаем класс для второго виджета
        config_widget.add_class('hidden')
        sleep(.3)
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return


        # Сортируем audio_list по возрастанию даты и времени
        audio_list = sorted(audio_list, key=lambda x: datetime.strptime(x['date_time'], '%Y-%m-%d_%H-%M-%S') if x['date_time'] != "---" else datetime.min)
        progress.value = 85  # Обновляем прогресс
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        # Фильтруем список по операторам и получаем статистику
        records_list, call_stats = get_records_by_list(audio_list, max_records=config['MAX_RECORDS'])
        progress.value = 90  # Обновляем прогресс
        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        # clear_output()
        # Статистика всех записей по операторам
        print(f"Всего записей: {len(audio_list)}\n-----------------------------------")
        for operator, num_calls in call_stats.items():
            # Фильтруем записи по оператору
            filtered_records = [record for record in audio_list if record['to_number'] == operator]

            if filtered_records:
                # Определяем минимальную и максимальную дату для каждого оператора
                min_date = min(datetime.strptime(record['date_time'], '%Y-%m-%d_%H-%M-%S') for record in filtered_records)
                max_date = max(datetime.strptime(record['date_time'], '%Y-%m-%d_%H-%M-%S') for record in filtered_records)

                # Выводим статистику с периодом звонков
                print(f"Оператор: \033[1;36m{operator:<12}\033[0m "
                      f"Записей: \033[1;34m{num_calls:<5}\033[0m "
                      f"Период звонков: с \033[1;32m{min_date.strftime('%Y-%m-%d %H:%M:%S')}\033[0m "
                      f"по \033[1;32m{max_date.strftime('%Y-%m-%d %H:%M:%S')}\033[0m")
        progress.value = 95  # Обновляем прогресс

        # Получаем список операторов и приводим их к единому формату
        operator_list = [operator.strip() for operator in config['OPERATOR_LIST'].split(',')] if config['OPERATOR_LIST'] else []

        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        if operator_list:
            print(f"\nСписок операторов (OPERATOR_LIST): \033[1;34m{', '.join(operator_list)}\033[0m\n-----------------------------------")
            # Приводим операторы к единому формату, удаляя ведущие нули
            normalized_operator_list = [operator.lstrip('0') for operator in operator_list]

            # Фильтруем records_list по операторам из operator_list
            records_list = [record for record in records_list if record['to_number'].lstrip('0') in normalized_operator_list]
        else:
            print(f"\nСписок операторов для анализа (OPERATOR_LIST): \033[1;34mВсе операторы\033[0m\n-----------------------------------")

        print(f"\nВыбрано записей для транскрибации: \033[1;34m{len(records_list)}\033[0m\n-----------------------------------")

        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        # Вывод информации по операторам
        for operator, num_calls in call_stats.items():
            # Фильтруем записи по оператору 'to_number' с учетом фильтрации по operator_list
            filtered_records = [record for record in records_list if record['to_number'] == operator]

            if filtered_records:
                # Получаем минимальную и максимальную дату
                min_date = min(datetime.strptime(record['date_time'], '%Y-%m-%d_%H-%M-%S') for record in filtered_records)
                max_date = max(datetime.strptime(record['date_time'], '%Y-%m-%d_%H-%M-%S') for record in filtered_records)

                # Форматируем вывод для второго блока
                print(f"Оператор: \033[1;36m{operator:<12}\033[0m "
                      f"Записей: \033[1;34m{len(filtered_records):<5}\033[0m "
                      f"Период звонков: с \033[1;32m{min_date.strftime('%Y-%m-%d %H:%M:%S')}\033[0m "
                      f"по \033[1;32m{max_date.strftime('%Y-%m-%d %H:%M:%S')}\033[0m")

        progress.value = 100  # Завершаем прогресс

    upload_button.disabled = False
    transcription_button.disabled = False
    cancel_button.disabled = True

# @title ====> **КНОПКА 3 - "ОТМЕНА".** Отмена обработки <====

def canсel_operation(event, client=None, verbose_level=1):
    #global is_running
    if not cancel_button.disabled:
        upload_button.disabled = False  # Устанавливаем флаг в False для отмены операции
        transcription_button.disabled = False  # Активируем кнопку транскрибации
        cancel_button.disabled = True
        reset_stop_loop()
        with output_area:
            #print("❌ Операция отменена")
            transcript_widget = widgets.HTML('<h2>❌ Операция отменена</h2>')
            display(transcript_widget)
        progress.value = 0

# @title Распознаем все файлы из списка и сохраняем их в Google Spreadsheets
# ВНИМАНИЕ!! Данный блок съедает много денег!
# Если records_list уже содержит поле 'text', то он пропускается

# Функция для сохранения records_list в Google Spreadsheet
def save_records_to_google_sheets(records_list, spreadsheet_url):

    # Открываем нужный лист на основе режима
    spreadsheet_id = parse_spreadsheet_id_by_url(spreadsheet_url)
    spreadsheet = gs_client.open_by_key(spreadsheet_id)
    worksheet = spreadsheet.worksheet(config['TRANSCRIPTS_RAW_WORKSHEET'])

    # Преобразуем список records_list в формат для записи в таблицу
    rows = []
    headers = ['Ссылка на файл', 'Имя файла', 'Оператор', 'Диалог', 'Длительность', 'Время обработки', 'Стоимость']  # Заголовки столбцов
    rows.append(headers)

    for record in records_list:
        # Формируем ссылку на файл по id
        file_link = f"https://drive.google.com/file/d/{record.get('id', '')}/view" if record.get('id', '') else 'Unknown'

        # Добавляем строку с данными в порядке, соответствующем заголовкам
        rows.append([
            file_link,                       # Ссылка на файл
            record.get('filename', ''),     # Имя файла
            record.get('to_number', ''),     # Оператор
            record.get('text', ''),          # Диалог
            record.get('duration', ''),      # Длительность
            record.get('elapsed_time', ''),  # Время обработки
            record.get('cost', '')           # Стоимость
        ])

    # Очистим лист перед записью
    worksheet.clear()

    # Записываем данные в таблицу
    worksheet.update(rows)
    print("Данные успешно записаны в Google Spreadsheet!")

# Основная функция с модификацией
def get_transcript_list(b):
    upload_button.disabled = True
    transcription_button.disabled = True
    cancel_button.disabled = False
    tmp_file = 'temp.mp3'
    with output_area:
        clear_output()

        # Устанавливаем начальное значение прогресс-бара
        progress.value = 0
        progress.max = len(records_list)

        # Создаем виджет для отображения текста
        transcript_widget = widgets.HTML('<h2>🕑 Идет транскрибация аудиозаписей...</h2>')
        display(transcript_widget)



        # Проверяем значение stopLoop из JavaScript
        if check_stop_loop():
            return

        for index, record in enumerate(records_list):
            if load_mp3_from_google_drive(record['id'], tmp_file) is not None:

                # Проверяем значение stopLoop из JavaScript
                if check_stop_loop():
                    return

                transcript = run_transcript(record, tmp_file)

                if transcript is not None:
                    # Дополняем данные
                    records_list[index]['text'] = transcript['text']
                    records_list[index]['duration'] = transcript['duration']
                    records_list[index]['elapsed_time'] = transcript['elapsed_time']
                    records_list[index]['cost'] = transcript['cost']

                # Удаление временного файла
                os.remove(tmp_file)

            # Выводим только имя файла
            print(f'Файл {index + 1} / {len(records_list)} : {record["filename"]} обработан')
            # Обновляем значение прогресс-бара
            progress.value += 1

        print('Все файлы распознаны')

        # Чекпоинт. Сохраняем результат в Google Spreadsheet
        save_records_to_google_sheets(records_list, config['CURRENT_SPREADSHEET_URL'])

        transcript_widget.value = '<h2>✅ Транскрибация успешно завершена.</h2>'
        progress.value = 100

    upload_button.disabled = False
    transcription_button.disabled = False
    cancel_button.disabled = True

"""### ======== Безусловно исполняемый код ========"""

# @title Системная конфигурация, ID рабочей таблицы.

# Таблица для работы
spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1OO5uLqbgG0AeIOue-cilsHhUuEcvxA_ymov0HXp1NvQ/edit' # URL рабочей таблицы
worksheet_name = 'Конфигурация' # Имя листа с конфигурацией
colab_id = 1 # ID данного ноутбука

# @title Подготовка. Загрузка основной Конфигурации из Google Spreadsheets

import pandas as pd
import gspread
from gspread_dataframe import get_as_dataframe
from google.oauth2.service_account import Credentials
import json
import re

from time import sleep

def parse_spreadsheet_id_by_url(url):
    # Используем регулярное выражение для извлечения spreadsheet_id из URL
    match = re.search(r'/d/([a-zA-Z0-9-_]+)', url)
    if match:
        return match.group(1)  # Получаем сам spreadsheet_id
    else:
        raise ValueError("Некорректная ссылка на Google Таблицу")

def spreadsheets_auth():
    # Устанавливаем область видимости API
    scopes = ["https://www.googleapis.com/auth/spreadsheets", "https://www.googleapis.com/auth/drive"]

    # Подключаем ключ API Google
    from google.colab import userdata
    service_account_info = userdata.get('GOOGLE_JSON')
    service_account_info_dict = json.loads(service_account_info)

    # Создаем объект учетных данных
    credentials = Credentials.from_service_account_info(service_account_info_dict, scopes=scopes)

    # Авторизуемся
    client = gspread.authorize(credentials)

    return client

def load_config(client, colab_id, spreadsheet_url):
    # Открываем нужный лист на основе режима
    spreadsheet_id = parse_spreadsheet_id_by_url(spreadsheet_url)
    spreadsheet = client.open_by_key(spreadsheet_id)
    worksheet = spreadsheet.worksheet(worksheet_name)

    # Загружаем данные из Google Таблицы в DataFrame
    df_config = get_as_dataframe(worksheet, dtype=str, header=0)

    # Заменяем все NaN, если они есть, на пустые строки
    df_config = df_config.fillna('')

    # Фильтруем строки, где Colab_ID == 0 или Colab_ID == colab_id
    df_filtered = df_config[(df_config['Colab_ID'] == '0') | (df_config['Colab_ID'] == str(colab_id))]

    # Пробежимся по строкам отфильтрованного датафрейма и заполним словарь
    config = {}

    for index, row in df_filtered.iterrows():
        constant_name = row['Константа']
        constant_value = row['Значение']
        config[constant_name] = constant_value

    return config

# Обертка к load_config
def re_config(client, colab_id, spreadsheet_url):
    config = load_config(client, colab_id, spreadsheet_url)
    if config['SPREADSHEED_OVERRIDE']:
        config = load_config(client, colab_id, config['SPREADSHEED_OVERRIDE'])
        config['CURRENT_SPREADSHEET_URL'] = config['SPREADSHEED_OVERRIDE']
    else:
        config['CURRENT_SPREADSHEET_URL'] = spreadsheet_url

    # Режим работы (не используется)
    # config['TEST_MODE'] = True if config['TEST_MODE'] == "1" else False # True - тестовый режим, False - рабочий режим

    return config

gs_client = spreadsheets_auth()
config = re_config(gs_client, colab_id, spreadsheet_url)

display(config)

# @title Установка библиотек, импорты и подключение к OpenAI
!pip install -q --upgrade openai
!pip install -q pydub
!pip install -q mutagen

import re
import requests
import openai
import getpass
import os
import io
import time
from pydub import AudioSegment
from mutagen.mp3 import MP3
from tqdm import tqdm

from openai import OpenAI
import os
from google.colab import userdata
openai_key = userdata.get('OPENAI_API_KEY');
os.environ["OPENAI_API_KEY"] = openai_key

"""# Панель управления модулем транскрибации записей"""

# @title Панель управления модулем транскрибации записей
import ipywidgets as widgets
from IPython.display import display, clear_output, update_display
from IPython.core.display import HTML

# CSS и HTML для кнопок
style_html = widgets.HTML("""
<style>
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

.medsonar-header{
    text-align: left;
    margin-bottom: 40px;
    display: flex;
    flex-direction: column;
}

.custom-buttons{
    display: flex;
    flex-direction: column;
    margin-right:30px;
}

.custom-button {
    background-color: white;
    color: #00abb8;
    font-weight: bold;
    font-size:.95rem;
    text-transform: uppercase;
    border: #00abb8 2px solid;
    border-radius: 24px;
    padding: 10px 20px;
    margin: 0 0 10px 0;
    transition: background-color 0.3s, color 0.3s;
    font-family: 'Montserrat', sans-serif;
}
.cancel-button{
    color: #cf2d46;
    border-color: #cf2d46;
    outline: none;
}
.custom-button:hover {
    background-color: #00abb8;
    color: white;
    box-shadow: none!important;
}

.cancel-button:hover{
    background-color: #cf2d46;
    box-shadow: none;
    outline: none;
}
.custom-button:disabled {
    background-color: #e0e0e0; /* Светло-серый цвет */
    color: #aaaaaa; /* Тусклый текст */
    border-color: #cccccc; /* Светло-серый цвет границы */
}
/* Свой hover для disabled */
.custom-button:disabled:hover {
    background-color: #ddd; /* Серый цвет */
    color: #888; /* Серый текст */
    border-color: #bbb; /* Светло-серый цвет границы */
    cursor: auto;
}

.output-area{
    padding:10px;
    border-radius:3px;
}
h2 {
    font-size: 20px;
    line-height: 1;
    font-weight: bold;
}
h1, h2, h3, h4, h5 {
    font-family: 'Montserrat', sans-serif;
}


/* Начальные стили для виджетов */
.config-widget,
.status-widget {
  max-height: 150px; /* Достаточно большое значение для плавного схлопывания */
  opacity: 1;
  overflow: hidden;
  transition: max-height .3s ease, opacity .3s ease;
}

/* Стили для скрытого состояния */
.hidden {
  max-height: 0;
}
</style>
""")

# Приветственная надпись
welcome_label = widgets.HTML(
    value=f"""
    <div class='medsonar-header'>
        <span style='font-size: 2rem; font-weight:bold; color:#333;'>Система нейроконтроля качества медицинского центра Медсонар</span>
        <span style='font-size: 1rem; font-weight:bold; color:#333;'><br>Модуль 1. Cоздание транскрибаций по аудио записям</span>
    </div>
    """
)

# Форма для вывода служебной информации
output_area = widgets.Output(
    layout=widgets.Layout(
        width='1000px',
        height='400px',
        overflow='auto',
        border='1px solid #00abb8'  # Устанавливаем цвет окаймления
    )
)
with output_area:
    display(HTML("<h1 style='font-size: 20px;'><center>Вас приветствует система нейроконтроля качества! <br><br> Запустите получение списка файлов</center></h1>"))

#Виджет полосы статуса
progress = widgets.IntProgress(min=0, max=100, value=0, layout=widgets.Layout(width='1020px'))

# Кнопки
upload_button = widgets.Button(description="Получение списка файлов", layout=widgets.Layout(height='50px', width='330px'))
transcription_button = widgets.Button(description="Транскрибация", layout=widgets.Layout(height='50px', width='330px'))
cancel_button = widgets.Button(description="Отмена", layout=widgets.Layout(height='50px', width='330px'))

# Применение стиля к кнопкам
upload_button.add_class('custom-button')
transcription_button.add_class('custom-button')
cancel_button.add_class('custom-button')
cancel_button.add_class('cancel-button')
output_area.add_class('output-area')


def display_buttons():
    clear_output(wait=True)
    display(welcome_label)

    button_box = widgets.VBox([upload_button, transcription_button, cancel_button],
                              layout=widgets.Layout(width='350px'))
    # Создаем вертикальный контейнер для output_area и progress
    output_and_progress_box = widgets.VBox([output_area, progress])
    hbox = widgets.HBox([button_box, output_and_progress_box])
    display(style_html)
    display(hbox)


# Привязка кнопок к функциям
upload_button.on_click(on_upload_button_click)
transcription_button.on_click(get_transcript_list)
cancel_button.on_click(canсel_operation)

# Вывод виджетов
display(style_html)
display_buttons()

cancel_button.disabled = True

js_code = """
<script>
    // Функция для сброса флага остановки цикла
    function resetStopLoop() {
        if (stopLoop) {
            stopLoop = false;
            console.log("JavaScript: Флаг остановки сброшен, stopLoop = false");
        }
    }

    document.querySelectorAll('.cancel-button').forEach((el, index) => {
        if (el.textContent.includes('Отмена')) {
            el.setAttribute('id', 'cancelButton');
        }
    });
    var stopLoop = false;
    document.getElementById('cancelButton').onclick = function() {
        stopLoop = true;
        console.log("JavaScript: Кнопка нажата, stopLoop = true");
        this.disabled = true; // Сделать кнопку недоступной после нажатия
        this.textContent = "🕑 Операция отменяется..."; // Изменить текст кнопки
    }
</script>
"""
display(HTML(js_code))